#+property: header-args :tangle .zshrc
#+title: My literate, frameworkless zsh configuration
# Note: export with org-babel-tangle (C-c C-v t)
# More info at: https://org-babel.readthedocs.io/en/latest/header-args/#tangle

* Table of Contents                                                   :TOC_3:
- [[#introduction][Introduction]]
  - [[#how-the-magic-is-done][How the magic is done]]
- [[#history-file-settings][History file settings]]
- [[#bootstrapping-the-prompt][Bootstrapping the prompt]]
- [[#colored-man-pages-without-a-plugin][Colored man pages without a plugin]]
- [[#keybindings][Keybindings]]
  - [[#bind-ctrl-leftright-to-move-back-and-forward-word][Bind ctrl-left/right to move back and forward word]]
  - [[#have-arrow-keys-search-history-while-typing-a-command][Have arrow keys search history while typing a command]]
- [[#functions][Functions]]
  - [[#history-beginning-search-menu][history-beginning-search-menu]]
  - [[#edit-command-line][edit-command-line]]
  - [[#custom-functions][Custom functions]]
- [[#set-the-terminal-title][Set the terminal title]]
- [[#completion-settings][Completion settings]]
- [[#zsh-options][Zsh options]]
  - [[#autocorrection][Autocorrection]]
- [[#aliases][Aliases]]
- [[#settings-for-external-programs][Settings for external programs]]
  - [[#setting-for-less][Setting for less]]
  - [[#enable-true-color-for-the-micro-text-editor][Enable true color for the micro text editor]]

* Introduction
For a while I was using zsh with the [[https://github.com/robbyrussell/oh-my-zsh/][oh-my-zsh]] framework. However, as I became more advanced in using Linux, and started writing my own dotfiles, I realised I had no idea what this thing was doing, and decided to examine my shell using habits to see if I even needed oh-my-zsh at all. It turns out that I wasn't really using much of what oh-my-zsh offers (I wasn't even using any significant plugins), so I could get rid of this framework. I pondered whether I should use [[https://github.com/zplug/zplug][zplug]], which is a plugin manager, but I was using only two plugins and thus concluded that it wasn't worth it and decided my make my config without any frameworks and plugin managers whatsoever. I did however want to make my config literate, in order to be able to note the thought process behind each setting and where I found various code snippets, and there's no better way to make one's config literate than Emacs's org mode, with which I'm already acquainted due to my other dotfiles.
** How the magic is done
I put in the beginning of this org file the string
#+begin_example
#+property: header-args :tangle .zshrc
#+end_example
which tells the src blocks to get tangled (= exported) to a file called .zshrc, so that zsh will be able to see it. For the src blocks themselves, I'm using ~begin_src sh~ as this gets syntax highlighting on both emacs itself and Github.
* History file settings
The history file is necessary, as this is what's used for reverse history search. I named it ~.zsh_history~ instead of the default ~.histfile~ and increased the number of entries to save [[https://github.com/robbyrussell/oh-my-zsh/blob/master/lib/history.zsh#L30][according to their setting on oh-my-zsh]].
#+begin_src sh
HISTFILE=~/.zsh_history
HISTSIZE=50000
SAVEHIST=10000
#+end_src
* Bootstrapping the prompt
I'm using the [[https://github.com/agkozak/agkozak-zsh-prompt][agkozak zsh prompt]]. Here I have a conditional (the code of which is adapted from [[https://github.com/zplug/zplug/wiki/Configurations#examples][here]]) that detects if the directory in which the code of said prompt resides exists and, if not, clones the github repo (note that this obviously requires git). Immediately afterwards the prompt is sourced.
#+begin_src sh
#autoinstall the agkozak zsh prompt
if [[ ! -d ~/agkozak-zsh-prompt ]]; then
  git clone https://github.com/agkozak/agkozak-zsh-prompt ~/agkozak-zsh-prompt
fi
#source it
source ~/agkozak-zsh-prompt/agkozak-zsh-prompt.plugin.zsh
#+end_src
Regarding the settings of said prompt, I want the git info to be on the left side of the prompt (see [[https://github.com/agkozak/agkozak-zsh-prompt#optional-left-prompt-only-mode][here]]).
#+begin_src sh
AGKOZAK_LEFT_PROMPT_ONLY=1
#+end_src
* Colored man pages without a plugin
Here I have the man pages be colored without any plugins. I used to use [[https://github.com/robbyrussell/oh-my-zsh/blob/master/plugins/colored-man-pages/colored-man-pages.plugin.zsh][the colored-man-pages plugin from oh-my-zsh]], but as I started looking into the oh-my-zsh codebase to see what I could safely discard or replace, I found
out that this didn't need a plugin nor any sort of complicated code to be configured, as all it takes is to write ~export LESS_TERMCAP_~ in the rc files (see [[https://russellparker.me/post/2018/02/23/adding-colors-to-man/][Russell Parker | Adding Colors to man]] and [[https://www.topbug.net/blog/2016/09/27/make-gnu-less-more-powerful/][Make the less Command More Powerful - Top Bug Net]]). Note that this draws the colors from the colors 1-8 of the used terminal emulator colorscheme, and thus the resulting look will depend on said colorscheme.
#+begin_src sh
export LESS_TERMCAP_md=$(tput bold; tput setaf 1)
export LESS_TERMCAP_me=$(tput sgr0)
export LESS_TERMCAP_mb=$(tput bold; tput setaf 2)
export LESS_TERMCAP_us=$(tput bold; tput setaf 2)
export LESS_TERMCAP_ue=$(tput rmul; tput sgr0)
export LESS_TERMCAP_so=$(tput bold; tput setaf 3; tput setab 4)
export LESS_TERMCAP_se=$(tput rmso; tput sgr0)
#+end_src
* Keybindings
Bindkey: Let's just use emacs keybindings, as I'm not the kind to want to have vim keybindings everywhere.
#+begin_src sh
bindkey -e
#+end_src
** Bind ctrl-left/right to move back and forward word
Found from [[https://github.com/robbyrussell/oh-my-zsh/blob/master/lib/key-bindings.zsh#L52][here]]. Note that with the emacs keymap, M-b and M-f can be used for the same purpose, they're just a little harder to remember.
#+begin_src sh
bindkey "^[[1;5C" forward-word
bindkey "^[[1;5D" backward-word
#+end_src
** Have arrow keys search history while typing a command
A behavior that oh-my-zsh has that I wanted to keep was using the up and down arrow to find matches from the history for the command currently being typed e.g. pressing up/down after writing ~man z~ will search in the history for commands beginning with ~man~ and of which the first letter of second word was z. I found the necessary config [[https://github.com/robbyrussell/oh-my-zsh/blob/master/lib/key-bindings.zsh#L30][here]]. For the record, the functions ~up-line-or-beginning-search~ and ~down-line-or-beginning search~, which are enabled here, are, according to ~man zshcontrib~, similar to the builtin functions ~up-line-or-search~ and ~down-line-or-search~, but they search for a line which matches the current line up to the current cursor position, rather than the first word on the line.
#+begin_src sh
# start typing + [Up-Arrow] - fuzzy find history forward
if [[ "${terminfo[kcuu1]}" != "" ]]; then
  autoload -U up-line-or-beginning-search
  zle -N up-line-or-beginning-search
  bindkey "${terminfo[kcuu1]}" up-line-or-beginning-search
fi
# start typing + [Down-Arrow] - fuzzy find history backward
if [[ "${terminfo[kcud1]}" != "" ]]; then
  autoload -U down-line-or-beginning-search
  zle -N down-line-or-beginning-search
  bindkey "${terminfo[kcud1]}" down-line-or-beginning-search
fi
#+end_src
* Functions
** history-beginning-search-menu
I found via ~man zshcontrib~ about the existence of many functions that come with zsh but aren't enabled by default. One of them is ~history-beginning-search-menu~. This invokes a menu with numbers including those history commands that match the string that was typed, and a match can be selected by typing the appropriate number. When invoking in addition the command with the same name, but with the suffix ~-end~, the cursor goes to the end of the command after the match has been selected, otherwise it remains after the matched characters, and when combined with the command with the suffix ~-space~, any space in the line is matched as a wildcard, thus effectively making the search fuzzy (see [[https://www.mankier.com/1/zshcontrib#Zle_Functions-Widgets][the relevant entry in ~man zshcontrib~]] and [[https://github.com/zsh-users/zsh/blob/master/Functions/Zle/history-beginning-search-menu][the introductory comments of said function]]). I use here Ctrl-H for this functionality, as its default function is like backspace, which is kinda useless, as I can use the real backspace for that.
#+begin_src sh
autoload -Uz history-beginning-search-menu-space-end history-beginning-search-menu
zle -N history-beginning-search-menu-space-end history-beginning-search-menu
bindkey "^H" history-beginning-search-menu-space-end
#+end_src
** edit-command-line
Another function I found via ~man zshcontrib~ is ~edit-command-line~. This function edits the current command line using the visual editor, which seems rather useful, as when I want to compose long commands, I often write them on the text editor and then paste them on the command line. This helps in that after saving the changes and quitting from the temp file presented, the just written command appears in the command line, ready to be executed, no selecting and copying/pasting required. This function needs to be bound to a key, and I decided to bind it to Ctrl-x Ctrl-e, as I already have this in my muscle memory, since this is the keybinding I use to execute lisp code in the ~*scratch*~ buffer in emacs.
#+begin_src sh
autoload -Uz edit-command-line
zle -N edit-command-line
bindkey "^X^E" edit-command-line
#+end_src
** Custom functions
Custom function to create a directory and cd into it immediately (found from [[https://github.com/yochem/dotfiles/blob/master/.config/bash/functions#L67][here]])
#+begin_src sh
mkcd() { mkdir "$1"; cd "$1"; }
#+end_src
* Set the terminal title
Oh-my-zsh used to set the terminal title in such a manner as to show ~username@hostname:directory~ on the titlebar of the terminal emulator, and just the directory in the tool bar of the OS, but without the framework only the title of the terminal emulator (e.g. ~Terminal~) is shown on both places - not very useful. I took a look at [[https://github.com/robbyrussell/oh-my-zsh/blob/master/lib/termsupport.zsh][the code oh-my-zsh uses for this setting]] and found it too convoluted for me to use. Thankfully, [[https://github.com/robbyrussell/oh-my-zsh/blob/master/lib/termsupport.zsh#L5][a link on the top of the file]] pointed me to the right direction. [[http://www.faqs.org/docs/Linux-mini/Xterm-Title.html#ss4.1][Here]] I found a much simpler function (which however has the title be the same on both the terminal emulator title bar and the OS tool bar, but oh well...), and adapted it to my needs, removing the username and the hostname (as I'm the only user on my computer and I don't connect to any remote machines). I also recall that oh-my-zsh also showed the name of the currently running command, when this was the case, and found [[https://www.davidpashley.com/articles/xterm-titles-with-bash/][here]] how to implement this natively. So currently when a command is running, the title of the terminal emulator and the OS toolbar show its name, otherwise they show the name of the current directory.
#+begin_src sh
case $TERM in
    xterm*)
        precmd () {print -Pn "\e]0;%~\a"}
        preexec () {print -Pn "\e]0;$1\a"}
        ;;
esac
#+end_src
* Completion settings
Enable completion
#+begin_src sh
autoload -Uz compinit
compinit
#+end_src
Setting for menu selection in completion
#+begin_src sh
zstyle ':completion:*' menu select
#+end_src
List the completion matches in rows instead of columns.
#+begin_src sh
setopt list_rows_first
#+end_src
Setting so that when using a glob (e.g. *) it will show a menu for completion instead of putting all the filenames that satisfy the conditions of the glob on the command. Useful if I want to act on a file but don't exactly recall its name, and also if I wanted to act on all files of e.g. a specific filetype I wouldn't use tab to complete.
#+begin_src sh
setopt glob_complete
#+end_src
Enable ~LS_COLORS~ for the completion of files and directories.
#+begin_src sh
zstyle ':completion:*' list-colors "${(s.:.)LS_COLORS}"
#+end_src
* Zsh options
See ~man zshoptions~.\\
Automatically cd when the target is a directory without having to precede the target with ~cd~.
#+begin_src sh
setopt auto_cd
#+end_src
Append commands to the history file as soon as they are executed.
#+begin_src sh
setopt inc_append_history
#+end_src
Don't add a duplicate of the previous command into history.
#+begin_src sh
setopt histignoredups
#+end_src
Ignore the end of file sequence (ctrl-d).
#+begin_src sh
setopt ignoreeof
#+end_src
Prevent the forward history search shortcut (Ctrl-s) from being overtaken by the flow control (see [[http://zsh.sourceforge.net/Guide/zshguide04.html#l91][here]]).
#+begin_src sh
unsetopt flowcontrol
#+end_src
** Autocorrection
Autocorrect all wrong arguments.
#+begin_src sh
setopt correct_all
#+end_src
Make the autocorrect prompt fancier, by coloring the wrong argument with bold red and the right with bold green and showing the full names of the available options, also colored, with Yes as bold green, No as bold yellow, Abort as bold red and Edit as bold blue (adapted from [[https://www.refining-linux.org/archives/39-ZSH-Gem-4-Spell-checking-and-auto-correction.html][Refining Linux: ZSH Gem #4: Spell checking and auto correction]], with slight help from [[https://stackoverflow.com/a/6159885][here]]). Note that the look of this setting depends on the used terminal emulator colorscheme.
#+begin_src sh
autoload -U colors && colors
export SPROMPT="Correct $fg_bold[red]%R$reset_color to $fg_bold[green]%r?$reset_color ($fg_bold[green]Yes$reset_color, $fg_bold[yellow]No$reset_color, $fg_bold[red]Abort$reset_color, $fg_bold[blue]Edit$reset_color) "
#+end_src
* Aliases
#+begin_src sh
alias ls='ls --color=auto'
alias grep='grep --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'
alias ll='ls -lh'
alias la='ls -lah'
alias termclock="tty-clock -b -c -C 6 -f \"%A %d/%m/%y\" -B -a 100000000 -d 0"
#+end_src
* Settings for external programs
** Setting for less
After I uninstalled oh-my-zsh, I found out that the screen wasn't cleared anymore after quitting from the output of git-log, which was undesired, as I didn't want the output of git-log to remain printed on my terminal. Turns out that this was also [[https://github.com/robbyrussell/oh-my-zsh/blob/master/lib/misc.zsh#L22][set by oh-my-zsh]], and since I had come to expect this behavior, I set up here the less pager (used by git by default) with the settings that oh-my-zsh had.
#+begin_src sh
export LESS=-R
#+end_src
** Enable true color for the micro text editor
#+begin_src sh
export MICRO_TRUECOLOR=1
#+end_src
